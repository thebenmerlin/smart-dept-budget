import PDFDocument from 'pdfkit';

interface ReportData {
  title: string;
  subtitle?:  string;
  generatedAt: string;
  generatedBy: string;
  fiscalYear: string;
  department: string;
  data: any[];
  totals?:  Record<string, number>;
  columns:  { key: string; header: string; width?:  number; align?: 'left' | 'right' | 'center' }[];
}

export async function generatePDFReport(reportData: ReportData): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({ 
        size: 'A4', 
        margin: 50,
        info: {
          Title: reportData.title,
          Author: 'RSCOE CSBS Budget System',
          Subject:  reportData.subtitle || reportData.title,
        }
      });

      const chunks: Buffer[] = [];
      doc.on('data', (chunk) => chunks.push(chunk));
      doc.on('end', () => resolve(Buffer.concat(chunks)));
      doc.on('error', reject);

      // Header
      doc.fontSize(8).fillColor('#666666')
        .text("JSPM's Rajarshi Shahu College of Engineering", 50, 30, { align: 'center' })
        .text('Department of Computer Science and Business Systems', { align: 'center' });

      doc.moveDown(2);

      // Title
      doc.fontSize(18).fillColor('#243169')
        .text(reportData.title, { align: 'center' });
      
      if (reportData.subtitle) {
        doc.fontSize(12).fillColor('#666666')
          .text(reportData.subtitle, { align: 'center' });
      }

      doc.moveDown();

      // Meta info
      doc.fontSize(10).fillColor('#333333');
      doc.text(`Fiscal Year: ${reportData.fiscalYear}`, 50);
      doc.text(`Department: ${reportData.department}`);
      doc.text(`Generated: ${reportData.generatedAt}`);
      doc.text(`Generated By: ${reportData. generatedBy}`);

      doc.moveDown(2);

      // Table header
      const startX = 50;
      let currentY = doc.y;
      const rowHeight = 25;
      const pageWidth = doc.page.width - 100;

      // Calculate column widths
      const totalWidth = reportData.columns.reduce((sum, col) => sum + (col.width || 100), 0);
      const widthRatio = pageWidth / totalWidth;

      // Draw header background
      doc.rect(startX, currentY, pageWidth, rowHeight)
        .fill('#243169');

      // Draw header text
      let currentX = startX;
      doc.fillColor('#ffffff').fontSize(9);
      reportData.columns.forEach((col) => {
        const colWidth = (col.width || 100) * widthRatio;
        doc.text(col.header, currentX + 5, currentY + 8, {
          width: colWidth - 10,
          align: col.align || 'left',
        });
        currentX += colWidth;
      });

      currentY += rowHeight;

      // Draw data rows
      doc.fillColor('#333333').fontSize(9);
      reportData.data.forEach((row, index) => {
        // Check for page break
        if (currentY > doc.page.height - 100) {
          doc.addPage();
          currentY = 50;
        }

        // Alternate row background
        if (index % 2 === 0) {
          doc.rect(startX, currentY, pageWidth, rowHeight)
            .fill('#f8fafc');
        }

        // Draw row data
        currentX = startX;
        doc.fillColor('#333333');
        reportData.columns.forEach((col) => {
          const colWidth = (col.width || 100) * widthRatio;
          const value = row[col. key] ??  '-';
          doc. text(String(value), currentX + 5, currentY + 8, {
            width:  colWidth - 10,
            align:  col.align || 'left',
          });
          currentX += colWidth;
        });

        currentY += rowHeight;
      });

      // Totals row if provided
      if (reportData.totals) {
        currentY += 10;
        doc. rect(startX, currentY, pageWidth, rowHeight)
          .fill('#243169');

        currentX = startX;
        doc.fillColor('#ffffff').fontSize(10).font('Helvetica-Bold');
        reportData. columns.forEach((col) => {
          const colWidth = (col.width || 100) * widthRatio;
          const value = reportData. totals![col.key];
          doc.text(value !== undefined ? String(value) : '', currentX + 5, currentY + 8, {
            width: colWidth - 10,
            align: col.align || 'left',
          });
          currentX += colWidth;
        });
      }

      // Footer
      const pageCount = doc.bufferedPageRange().count;
      for (let i = 0; i < pageCount; i++) {
        doc.switchToPage(i);
        doc.fontSize(8).fillColor('#999999')
          .text(
            `Page ${i + 1} of ${pageCount}`,
            50,
            doc.page.height - 30,
            { align: 'center' }
          );
      }

      doc.end();
    } catch (error) {
      reject(error);
    }
  });
}

export async function generateCSVReport(
  columns: { key: string; header: string }[],
  data: any[]
): Promise<string> {
  const headers = columns.map((col) => `"${col.header}"`).join(',');
  
  const rows = data.map((row) => {
    return columns
      .map((col) => {
        const value = row[col.key] ?? '';
        // Escape quotes and wrap in quotes
        return `"${String(value).replace(/"/g, '""')}"`;
      })
      .join(',');
  });

  return [headers, ...rows]. join('\n');
}